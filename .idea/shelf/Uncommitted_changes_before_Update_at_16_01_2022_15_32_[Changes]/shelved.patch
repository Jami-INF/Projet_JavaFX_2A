Index: project/src/view/game.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package view;\r\nimport javafx.application.Platform;\r\nimport javafx.beans.binding.Bindings;\r\nimport javafx.beans.binding.When;\r\nimport javafx.fxml.FXMLLoader;\r\nimport javafx.geometry.BoundingBox;\r\nimport javafx.scene.image.ImageView;\r\nimport javafx.scene.layout.*;\r\nimport javafx.stage.Stage;\r\nimport javafx.scene.Scene;\r\nimport javafx.scene.Group;\r\nimport javafx.scene.canvas.Canvas;\r\nimport javafx.scene.canvas.GraphicsContext;\r\nimport javafx.scene.image.Image;\r\nimport javafx.scene.Parent;\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport controller.mouvement;\r\nimport javafx.event.EventHandler;\r\nimport javafx.geometry.VPos;\r\nimport javafx.scene.input.KeyEvent;\r\nimport javafx.scene.paint.Color;\r\nimport javafx.scene.text.Font;\r\nimport javafx.scene.text.TextAlignment;\r\nimport controller.*;\r\nimport model.Joueur;\r\nimport model.*;\r\nimport javafx.animation.AnimationTimer;\r\n\r\npublic class game {\r\n    static Scene s;\r\n\r\n    long timegame = 0;\r\n    private Integer timejeu = 0;\r\n    private Integer timetmp = 0;\r\n    Boolean isCollide;\r\n    int DureeSaut = 10;//surée saut en tick\r\n    int tmpDureeSaut;\r\n\r\n    public void startgame(Stage stage) {\r\n        //System.out.println(\"fdfzfzdfzf\");\r\n        Group g = new Group();\r\n        s = new Scene(g,1280,720);\r\n        stage.setScene(s);\r\n        collision collisionController = new collision();\r\n        mouvement mouvementJoueur = new mouvement();\r\n        ActionMouvement(mouvementJoueur);\r\n        ////BACKGROUND\r\n        Image background = new Image (getClass().getClassLoader().getResource(\"image/background.jpg\").toExternalForm());\r\n        ImageView backgroundIV = new ImageView (getClass().getClassLoader().getResource(\"image/background.jpg\").toExternalForm());\r\n        g.getChildren().add(backgroundIV);\r\n        ////////////\r\n\r\n        ////JOUEUR\r\n        Image Skin = new Image(getClass().getClassLoader().getResource(\"image/testpers.png\").toExternalForm());\r\n        Joueur j1 = new Joueur(Skin, 20, 20, 10, 0, 0,\"Joueur1\");\r\n\r\n\r\n        //ImageView joueurIV = new ImageView(getClass().getClassLoader().getResource(\"image/testpers.png\").toExternalForm());\r\n        ////////////\r\n\r\n        //Image bg = new Image(getClass().getClassLoader().getResource(\"image/background.png\").toExternalForm());\r\n\r\n        //s.setFill(Color.grayRgb(35));\r\n        ArrayList<Plateforme> plateformeArrayList = new ArrayList<Plateforme>();\r\n        ArrayList<Entite> entites = new ArrayList<Entite>();\r\n\r\n        Image Platform = new Image(getClass().getClassLoader().getResource(\"image/platform.png\").toExternalForm());\r\n        Plateforme p1 = new Plateforme(Platform, 100, 600, 100, 100, 200, true);\r\n        Plateforme p2 = new Plateforme(Platform, 100, 600, 100,300, 500,true);\r\n        Plateforme p3 = new Plateforme(Platform, 100, 600, 100, 500, 500,true);\r\n        Plateforme p4 = new Plateforme(Platform, 100, 600, 100, 700, 500,true);\r\n        Plateforme p5 = new Plateforme(Platform, 100, 600, 100, 900, 500,true);\r\n        Plateforme p6 = new Plateforme(Platform, 100, 600, 100, 800, 400,true);\r\n        Plateforme p7 = new Plateforme(Platform, 100, 600, 100, 700, 300,true);\r\n\r\n\r\n\r\n\r\n        plateformeArrayList.add(p1);\r\n        plateformeArrayList.add(p2);\r\n        plateformeArrayList.add(p3);\r\n        plateformeArrayList.add(p4);\r\n        plateformeArrayList.add(p5);\r\n        plateformeArrayList.add(p6);\r\n        plateformeArrayList.add(p7);\r\n\r\n        entites.add(j1);\r\n        entites.add(p1);\r\n        entites.add(p2);\r\n        entites.add(p3);\r\n        entites.add(p4);\r\n        entites.add(p5);\r\n        entites.add(p6);\r\n        entites.add(p7);\r\n\r\n\r\n        for (Entite enti : entites) {\r\n            g.getChildren().add(enti.getIV());\r\n        }\r\n\r\n        Thread t = new Thread(() -> {\r\n            while(true){\r\n                Boolean exit = true;\r\n                timetmp++;\r\n                timejeu = timetmp/60;\r\n                //long startTime = System.nanoTime();\r\n\r\n\r\n                //AffichTimeHautEcran(timejeu.toString(), canvas);\r\n\r\n                javafx.application.Platform.runLater(() -> {\r\n                    //j1.update(plateformeArrayList);\r\n                    collisionController.verify(plateformeArrayList);\r\n                    mouvementJoueur.ActionLectureListe(mouvementJoueur, j1, stage, entites);\r\n                });\r\n\r\n                try {\r\n                    Thread.sleep(50);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        });\r\n        t.start();\r\n        stage.show();\r\n\r\n        /*new AnimationTimer() {\r\n            public void handle(long currentNanoTime) {\r\n                Boolean exit = true;\r\n                timetmp++;\r\n                timejeu = timetmp/60;\r\n                //long startTime = System.nanoTime();\r\n\r\n\r\n                //AffichTimeHautEcran(timejeu.toString(), canvas);\r\n\r\n                //isCollide = mouvementJoueur.CheckCollision(j1, plateformeArrayList);\r\n                j1.update(plateformeArrayList);\r\n                mouvementJoueur.ActionLectureListe(mouvementJoueur, j1, stage, entites);\r\n\r\n\r\n\r\n\r\n            }\r\n        }.start();*/\r\n        stage.setScene(s);\r\n        stage.show();\r\n        //Long.toString(System.currentTimeMillis()-currentNanoTime)\r\n    }\r\n/*\r\n    private void AffichTimeHautEcran(String time, Canvas canvas){\r\n        graphicsContext.clearRect(20, 20, canvas.getWidth(),30);\r\n        graphicsContext.setTextAlign(TextAlignment.CENTER);\r\n        graphicsContext.setTextBaseline(VPos.CENTER);\r\n        graphicsContext.setFont(new Font(30));\r\n        graphicsContext.fillText(time, Math.round(canvas.getWidth()  / 2), 30);\r\n        graphicsContext.setFill(Color.WHITESMOKE);\r\n    }\r\n*/\r\n    private static void ActionMouvement (mouvement mouvementJoueur) {\r\n        s.setOnKeyPressed(\r\n                new EventHandler<KeyEvent>() {\r\n                    public void handle(KeyEvent e) {\r\n                        String in = e.getCode().toString();\r\n                        if ( !mouvementJoueur.getInput().contains(in) )\r\n                            mouvementJoueur.addInput( in );\r\n                    }\r\n                });\r\n        s.setOnKeyReleased(\r\n\r\n                new EventHandler<KeyEvent>() {\r\n                    public void handle(KeyEvent e) {\r\n                        String in = e.getCode().toString();\r\n                        mouvementJoueur.removeInput( in );\r\n                    }\r\n                });\r\n    }\r\n\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/project/src/view/game.java b/project/src/view/game.java
--- a/project/src/view/game.java	(revision 679b5b0aa11107999f56a7df48c9f96aa10c3cd2)
+++ b/project/src/view/game.java	(date 1642170042069)
@@ -106,22 +106,22 @@
                 timejeu = timetmp/60;
                 //long startTime = System.nanoTime();
 
-
                 //AffichTimeHautEcran(timejeu.toString(), canvas);
 
                 javafx.application.Platform.runLater(() -> {
                     //j1.update(plateformeArrayList);
-                    collisionController.verify(plateformeArrayList);
+                    collisionController.verify(plateformeArrayList, j1);
                     mouvementJoueur.ActionLectureListe(mouvementJoueur, j1, stage, entites);
                 });
 
                 try {
-                    Thread.sleep(50);
+                    Thread.sleep(20);
                 } catch (InterruptedException e) {
                     e.printStackTrace();
                 }
             }
         });
+        t.setDaemon(true);
         t.start();
         stage.show();
 
@@ -163,8 +163,8 @@
                 new EventHandler<KeyEvent>() {
                     public void handle(KeyEvent e) {
                         String in = e.getCode().toString();
-                        if ( !mouvementJoueur.getInput().contains(in) )
-                            mouvementJoueur.addInput( in );
+                        if ( !mouvementJoueur.getInput().contains(in))
+                            mouvementJoueur.addInput(in);
                     }
                 });
         s.setOnKeyReleased(
@@ -172,11 +172,8 @@
                 new EventHandler<KeyEvent>() {
                     public void handle(KeyEvent e) {
                         String in = e.getCode().toString();
-                        mouvementJoueur.removeInput( in );
+                        mouvementJoueur.removeInput(in);
                     }
                 });
     }
-
-
-
 }
Index: project/src/model/Joueur.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package model;\r\nimport controller.mouvement;\r\nimport javafx.geometry.BoundingBox;\r\nimport javafx.geometry.Bounds;\r\nimport javafx.scene.control.Skin;\r\nimport javafx.scene.image.Image;\r\n\r\nimport java.util.ArrayList;\r\n\r\npublic class Joueur extends Entite {\r\n\r\n    private int vie;\r\n    private String pseudo;\r\n    private double velociteY;\r\n    private double velociteX;\r\n    private boolean inJump;\r\n    private boolean canJump;\r\n    private boolean isMouvementAvant;\r\n    private boolean isMouvementArriere;\r\n    private double jumpHauteur = 150;\r\n    private double gravite = 10;\r\n    private double size;\r\n    private Image skin;\r\n    private double imageSize;\r\n    private boolean isCollideUp = false;\r\n    private boolean isCollideDown = false;\r\n    private boolean isCollideLeft = false;\r\n    private boolean isCollideRight = false;\r\n\r\n\r\n\r\n    public Joueur(Image Skin, double VelociteX, double VelociteY, double Size, double SpawnX, double SpawnY, String Pseudo) {\r\n        super(Skin, VelociteX, VelociteY, Size, SpawnX, SpawnY);\r\n        vie=10;//A modifier peut etre ?\r\n        Pseudo = pseudo;\r\n        isMouvementArriere=false;\r\n        isMouvementAvant = false;\r\n        velociteX = VelociteX;\r\n        velociteY = VelociteY;\r\n        size = Size;\r\n        skin = Skin;\r\n        imageSize = size;\r\n        setFitWidth(imageSize);\r\n        setFitHeight(imageSize);\r\n\r\n\r\n    }\r\n\r\n    public int getVie()\r\n    {\r\n        return vie;\r\n    }\r\n\r\n    public void setVie(int pv)\r\n    {\r\n        vie=pv;\r\n    }\r\n\r\n    public String getPseudo() {\r\n        return pseudo;\r\n    }\r\n\r\n    public void setPseudo(String pseudo) {\r\n        this.pseudo = pseudo;\r\n    }\r\n\r\n    public Boolean isInJump () {\r\n        return inJump;\r\n    }\r\n    public void setInJump (Boolean b) {\r\n        inJump = b;\r\n    }\r\n    public void mouvementavantX() {\r\n        isMouvementAvant = true;\r\n        isMouvementArriere = false;\r\n        isCollideLeft = false;\r\n        //IV.setX(IV.getX()+5);\r\n        //System.out.println(\"zefzfezfe\");\r\n    }\r\n    public void mouvementarriereX() {\r\n        isMouvementArriere = true;\r\n        isMouvementAvant = false;\r\n        isCollideRight = false;\r\n    }\r\n    public void arretmouvement(){\r\n        isMouvementArriere = false;\r\n        isMouvementAvant = false;\r\n        isCollideLeft = false;\r\n        isCollideRight = false;\r\n    }\r\n\r\n    public boolean getisMouvementArriere(){\r\n        return isMouvementArriere;\r\n    }\r\n    public boolean getisMouvementAvant(){\r\n        return isMouvementAvant;\r\n    }\r\n\r\n    public void saut() {\r\n        if(isCollideUp == false){\r\n            inJump = true;\r\n            if (canJump) {\r\n                velociteY = velociteY-jumpHauteur;//le problème est que le saut se fait en une frame, ducoup en faisant +40, il se tp dans la plateforme sans verifier la collision\r\n                gravite = 10;\r\n            }\r\n            canJump = false;\r\n        }\r\n\r\n\r\n    }\r\n    public void update(ArrayList<Plateforme> plateformeArrayList) {\r\n        //updateMouvementX(plateformeArrayList);//obstacle coté\r\n        //updateMouvementY(plateformeArrayList);//gravité + plateforme bas\r\n        velociteY += gravite;\r\n        IV.setY(getY() + velociteY);\r\n\r\n        double WidthJ = IV.getImage().getWidth();\r\n        double HeightJ = IV.getImage().getHeight();\r\n        BoundingBox joueurBound = new BoundingBox(IV.getX(), IV.getY(), WidthJ, HeightJ);\r\n        //COORDONNES JOUEUR\r\n        double BasJ = joueurBound.getMaxY();\r\n        double HautJ = joueurBound.getMinY();\r\n        double GaucheJ = joueurBound.getMinX();\r\n        double DroiteJ = joueurBound.getMaxX();\r\n        for (Plateforme p : plateformeArrayList){\r\n            double WidthP =  p.getIV().getImage().getWidth();\r\n            double HeightP = p.getIV().getImage().getHeight();\r\n            BoundingBox platformBound = new BoundingBox(p.IV.getX(), p.IV.getY(), WidthP, HeightP);\r\n            //COORDONNES PLATEFORME\r\n            double BasP = platformBound.getMaxY();\r\n            double HautP = platformBound.getMinY();\r\n            double GaucheP = platformBound.getMinX();\r\n            double DroiteP = platformBound.getMaxX();\r\n\r\n            // COLLISION PAR LA GAUCHE X\r\n            if(GaucheJ >= DroiteP && HautP <= HautJ && BasP >= BasJ){\r\n            //if(GaucheJ >= DroiteP){\r\n                isCollideLeft = true;\r\n                //System.out.println(\"collision gauche\");\r\n            }\r\n\r\n            //COLLISION PAR LA DROITE X\r\n            if(DroiteJ >= GaucheP && HautJ <= HautP && BasJ >= BasP){\r\n                isCollideRight = true;\r\n                //System.out.println(\"collision droite\");\r\n            }\r\n\r\n            //COLLISION TETE Y\r\n            if(HautP >= BasJ && HautJ >= BasP && GaucheJ <= DroiteP && DroiteJ >= GaucheP){\r\n                isCollideUp = true;\r\n                canJump = false;\r\n                //System.out.println(\"collision tete\");\r\n            }\r\n\r\n            //COLLISION SOL\r\n            if(BasJ >= HautP && BasP >= HautJ && GaucheJ <= DroiteP && DroiteJ >= GaucheP){\r\n                isCollideDown = true;\r\n                canJump = true;\r\n                //System.out.println(\"collision sol\");\r\n            }\r\n        }\r\n\r\n        isCollideDown = false;\r\n        isCollideUp = false;\r\n        isCollideLeft = false;\r\n        isCollideRight = false;\r\n        gravite=10;\r\n\r\n        if(isCollideUp){\r\n            velociteY=0;\r\n        }\r\n\r\n        if(isCollideDown){\r\n            velociteY=0;\r\n            gravite=0;\r\n        }\r\n\r\n        if (isCollideRight){\r\n            velociteX=0;\r\n        }\r\n        if (isCollideLeft){\r\n            velociteX=0;\r\n        }\r\n    }\r\n    /*\r\n    public Boolean CheckCollision (ArrayList<Plateforme> plateformeArrayList) {\r\n        double WidthJ = IV.getImage().getWidth();\r\n        double HeightJ = IV.getImage().getHeight();\r\n        BoundingBox joueurBound = new BoundingBox(IV.getX(), IV.getY(), WidthJ, HeightJ);\r\n\r\n        //pour toutes les plateformes dans la liste\r\n        for (Plateforme p : plateformeArrayList){\r\n            double WidthP =  p.getIV().getImage().getWidth();\r\n            double HeightP = p.getIV().getImage().getHeight();\r\n            BoundingBox platformBound = new BoundingBox(p.IV.getX(), p.IV.getY(), WidthP, HeightP);\r\n\r\n            if( platformBound.intersects(joueurBound) ) {\r\n                //System.out.println(\"Collision\");\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }//Y hauteur // X largeur*/\r\n/*\r\n    public Boolean CheckCollision (Plateforme p) {\r\n        double WidthJ = IV.getImage().getWidth();\r\n        double HeightJ = IV.getImage().getHeight();\r\n        BoundingBox joueurBound = new BoundingBox(IV.getX(), IV.getY(), WidthJ, HeightJ);\r\n        double WidthP =  p.getIV().getImage().getWidth();\r\n        double HeightP = p.getIV().getImage().getHeight();\r\n        BoundingBox platformBound = new BoundingBox(p.IV.getX(), p.IV.getY(), WidthP, HeightP);\r\n        if( platformBound.intersects(joueurBound) ) {\r\n            //System.out.println(\"Collision\");\r\n            return true;\r\n        }\r\n        return false;\r\n    }//Y hauteur // X largeur\r\n    */\r\n\r\n    /*public void updateMouvementX(ArrayList<Plateforme> plateformeArrayList){\r\n        if (isCollideRight == false){\r\n            if (isMouvementAvant) {\r\n                IV.setX(IV.getX() + velociteX);\r\n            }\r\n        }\r\n        if (isCollideLeft == false){\r\n            if (isMouvementArriere) {\r\n                IV.setX(IV.getX() - velociteX);\r\n            }\r\n        }\r\n        double WidthJ = IV.getImage().getWidth();\r\n        double HeightJ = IV.getImage().getHeight();\r\n        BoundingBox joueurBound = new BoundingBox(IV.getX(), IV.getY(), WidthJ, HeightJ);\r\n        //COORDONNES JOUEUR\r\n        double BasJ = joueurBound.getMaxY();\r\n        double HautJ = joueurBound.getMinY();\r\n        double GaucheJ = joueurBound.getMinX();\r\n        double DroiteJ = joueurBound.getMaxX();\r\n        for (Plateforme p : plateformeArrayList){\r\n            double WidthP =  p.getIV().getImage().getWidth();\r\n            double HeightP = p.getIV().getImage().getHeight();\r\n            BoundingBox platformBound = new BoundingBox(p.IV.getX(), p.IV.getY(), WidthP, HeightP);\r\n            //COORDONNES PLATEFORME\r\n            double BasP = platformBound.getMaxY();\r\n            double HautP = platformBound.getMinY();\r\n            double GaucheP = platformBound.getMinX()-5;\r\n            double DroiteP = platformBound.getMaxX()-5;\r\n            //Bounds bounds = p.getLayoutBounds();\r\n            if(GaucheJ >= DroiteP){ // COLLISION PAR LA GAUCHE X\r\n                isCollideLeft = true;\r\n                System.out.println(\"collision gauche : gaucheJ\");\r\n\r\n            }\r\n            if(DroiteJ >= GaucheP && HautJ <= HautP && BasJ >= BasP){ //COLLISION PAR LA DROITE X\r\n                isCollideRight = true;\r\n                System.out.println(\"collision droite : DroiteJ\");\r\n                System.out.println(DroiteJ);\r\n                System.out.println(GaucheP);\r\n            }\r\n        }\r\n    }\r\n\r\n    void updateMouvementY(ArrayList<Plateforme> plateformeArrayList) {\r\n        velociteY += gravite;\r\n        IV.setY(getY() + velociteY);\r\n        double WidthJ = IV.getImage().getWidth();\r\n        double HeightJ = IV.getImage().getHeight();\r\n\r\n        BoundingBox joueurBound = new BoundingBox(IV.getX(), IV.getY(), WidthJ, HeightJ);\r\n        //COORDONNES JOUEUR\r\n        double BasJ = joueurBound.getMaxY();\r\n        double HautJ = joueurBound.getMinY();\r\n        double GaucheJ = joueurBound.getMinX();\r\n        double DroiteJ = joueurBound.getMaxX();\r\n        //System.out.println(HautJ);\r\n        //POUR TOUTES LES PLATEFORMES\r\n        for (Plateforme p : plateformeArrayList){\r\n            double WidthP =  p.getIV().getImage().getWidth();\r\n            double HeightP = p.getIV().getImage().getHeight();\r\n            BoundingBox platformBound = new BoundingBox(p.IV.getX(), p.IV.getY(), WidthP, HeightP);\r\n            //COORDONNES PLATEFORME\r\n            double BasP = platformBound.getMaxY();\r\n            double HautP = platformBound.getMinY();\r\n            double GaucheP = platformBound.getMinX();\r\n            double DroiteP = platformBound.getMaxX();\r\n            //System.out.println(HautP);\r\n            //System.out.println(\"hautP: \");\r\n            //System.out.println(HautP);\r\n            //System.out.println(\"basJ\");\r\n            //System.out.println(BasJ);\r\n            if(BasJ >= HautP && GaucheJ <= DroiteP && DroiteJ >= GaucheP){ //COLLISION SOL Y\r\n                isCollideDown = true;\r\n                gravite = 0;\r\n                canJump = true;\r\n                System.out.println(\"collision sol\");\r\n\r\n            }\r\n            if(HautJ >= BasP && GaucheJ <= DroiteP && DroiteJ >= GaucheP){ //COLLISION TETE Y\r\n                isCollideUp = true;\r\n                gravite = 10;\r\n                canJump = false;\r\n                System.out.println(\"collision tete\");\r\n\r\n            }\r\n        }\r\n    }*/\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/project/src/model/Joueur.java b/project/src/model/Joueur.java
--- a/project/src/model/Joueur.java	(revision 679b5b0aa11107999f56a7df48c9f96aa10c3cd2)
+++ b/project/src/model/Joueur.java	(date 1642170001158)
@@ -1,8 +1,5 @@
 package model;
-import controller.mouvement;
 import javafx.geometry.BoundingBox;
-import javafx.geometry.Bounds;
-import javafx.scene.control.Skin;
 import javafx.scene.image.Image;
 
 import java.util.ArrayList;
@@ -31,7 +28,7 @@
 
     public Joueur(Image Skin, double VelociteX, double VelociteY, double Size, double SpawnX, double SpawnY, String Pseudo) {
         super(Skin, VelociteX, VelociteY, Size, SpawnX, SpawnY);
-        vie=10;//A modifier peut etre ?
+        vie=10;
         Pseudo = pseudo;
         isMouvementArriere=false;
         isMouvementAvant = false;
@@ -42,8 +39,6 @@
         imageSize = size;
         setFitWidth(imageSize);
         setFitHeight(imageSize);
-
-
     }
 
     public int getVie()
@@ -67,21 +62,46 @@
     public Boolean isInJump () {
         return inJump;
     }
+
     public void setInJump (Boolean b) {
         inJump = b;
     }
+
+    public double getGravite(){ return gravite; }
+
+    public void setGravite(double grav){ gravite = grav; }
+
     public void mouvementavantX() {
         isMouvementAvant = true;
         isMouvementArriere = false;
         isCollideLeft = false;
-        //IV.setX(IV.getX()+5);
-        //System.out.println("zefzfezfe");
     }
     public void mouvementarriereX() {
         isMouvementArriere = true;
         isMouvementAvant = false;
         isCollideRight = false;
     }
+    public void mouvementRight(){
+        isMouvementArriere = false;
+        isMouvementAvant = true;
+    }
+    public void mouvementLeft(){
+        isMouvementArriere = true;
+        isMouvementAvant = false;
+    }
+
+    public boolean mouvementUp(){
+        if(!isCollideUp){
+            inJump=true;
+            if(canJump){
+                velociteY = velociteY + jumpHauteur;
+                gravite = 10;
+            }
+            canJump = false;
+        }
+        return inJump;
+    }
+
     public void arretmouvement(){
         isMouvementArriere = false;
         isMouvementAvant = false;
@@ -96,24 +116,32 @@
         return isMouvementAvant;
     }
 
+
+
     public void saut() {
         if(isCollideUp == false){
             inJump = true;
             if (canJump) {
-                velociteY = velociteY-jumpHauteur;//le problème est que le saut se fait en une frame, ducoup en faisant +40, il se tp dans la plateforme sans verifier la collision
+                velociteY = velociteY-jumpHauteur;
+                //le problème est que le saut se fait en une frame, ducoup en faisant +40, il se tp dans la plateforme sans verifier la collision
                 gravite = 10;
             }
             canJump = false;
         }
+    }
 
+    public void gravite(){
+        velociteY += gravite;
+        IV.setY(getY() + velociteY);
+    }
 
-    }
     public void update(ArrayList<Plateforme> plateformeArrayList) {
         //updateMouvementX(plateformeArrayList);//obstacle coté
         //updateMouvementY(plateformeArrayList);//gravité + plateforme bas
+
+        //GRAVITE
         velociteY += gravite;
         IV.setY(getY() + velociteY);
-
         double WidthJ = IV.getImage().getWidth();
         double HeightJ = IV.getImage().getHeight();
         BoundingBox joueurBound = new BoundingBox(IV.getX(), IV.getY(), WidthJ, HeightJ);
@@ -134,7 +162,7 @@
 
             // COLLISION PAR LA GAUCHE X
             if(GaucheJ >= DroiteP && HautP <= HautJ && BasP >= BasJ){
-            //if(GaucheJ >= DroiteP){
+                //if(GaucheJ >= DroiteP){
                 isCollideLeft = true;
                 //System.out.println("collision gauche");
             }
@@ -156,7 +184,7 @@
             if(BasJ >= HautP && BasP >= HautJ && GaucheJ <= DroiteP && DroiteJ >= GaucheP){
                 isCollideDown = true;
                 canJump = true;
-                //System.out.println("collision sol");
+                System.out.println("collision sol");
             }
         }
 
@@ -169,7 +197,6 @@
         if(isCollideUp){
             velociteY=0;
         }
-
         if(isCollideDown){
             velociteY=0;
             gravite=0;
@@ -182,126 +209,4 @@
             velociteX=0;
         }
     }
-    /*
-    public Boolean CheckCollision (ArrayList<Plateforme> plateformeArrayList) {
-        double WidthJ = IV.getImage().getWidth();
-        double HeightJ = IV.getImage().getHeight();
-        BoundingBox joueurBound = new BoundingBox(IV.getX(), IV.getY(), WidthJ, HeightJ);
-
-        //pour toutes les plateformes dans la liste
-        for (Plateforme p : plateformeArrayList){
-            double WidthP =  p.getIV().getImage().getWidth();
-            double HeightP = p.getIV().getImage().getHeight();
-            BoundingBox platformBound = new BoundingBox(p.IV.getX(), p.IV.getY(), WidthP, HeightP);
-
-            if( platformBound.intersects(joueurBound) ) {
-                //System.out.println("Collision");
-                return true;
-            }
-        }
-        return false;
-    }//Y hauteur // X largeur*/
-/*
-    public Boolean CheckCollision (Plateforme p) {
-        double WidthJ = IV.getImage().getWidth();
-        double HeightJ = IV.getImage().getHeight();
-        BoundingBox joueurBound = new BoundingBox(IV.getX(), IV.getY(), WidthJ, HeightJ);
-        double WidthP =  p.getIV().getImage().getWidth();
-        double HeightP = p.getIV().getImage().getHeight();
-        BoundingBox platformBound = new BoundingBox(p.IV.getX(), p.IV.getY(), WidthP, HeightP);
-        if( platformBound.intersects(joueurBound) ) {
-            //System.out.println("Collision");
-            return true;
-        }
-        return false;
-    }//Y hauteur // X largeur
-    */
-
-    /*public void updateMouvementX(ArrayList<Plateforme> plateformeArrayList){
-        if (isCollideRight == false){
-            if (isMouvementAvant) {
-                IV.setX(IV.getX() + velociteX);
-            }
-        }
-        if (isCollideLeft == false){
-            if (isMouvementArriere) {
-                IV.setX(IV.getX() - velociteX);
-            }
-        }
-        double WidthJ = IV.getImage().getWidth();
-        double HeightJ = IV.getImage().getHeight();
-        BoundingBox joueurBound = new BoundingBox(IV.getX(), IV.getY(), WidthJ, HeightJ);
-        //COORDONNES JOUEUR
-        double BasJ = joueurBound.getMaxY();
-        double HautJ = joueurBound.getMinY();
-        double GaucheJ = joueurBound.getMinX();
-        double DroiteJ = joueurBound.getMaxX();
-        for (Plateforme p : plateformeArrayList){
-            double WidthP =  p.getIV().getImage().getWidth();
-            double HeightP = p.getIV().getImage().getHeight();
-            BoundingBox platformBound = new BoundingBox(p.IV.getX(), p.IV.getY(), WidthP, HeightP);
-            //COORDONNES PLATEFORME
-            double BasP = platformBound.getMaxY();
-            double HautP = platformBound.getMinY();
-            double GaucheP = platformBound.getMinX()-5;
-            double DroiteP = platformBound.getMaxX()-5;
-            //Bounds bounds = p.getLayoutBounds();
-            if(GaucheJ >= DroiteP){ // COLLISION PAR LA GAUCHE X
-                isCollideLeft = true;
-                System.out.println("collision gauche : gaucheJ");
-
-            }
-            if(DroiteJ >= GaucheP && HautJ <= HautP && BasJ >= BasP){ //COLLISION PAR LA DROITE X
-                isCollideRight = true;
-                System.out.println("collision droite : DroiteJ");
-                System.out.println(DroiteJ);
-                System.out.println(GaucheP);
-            }
-        }
-    }
-
-    void updateMouvementY(ArrayList<Plateforme> plateformeArrayList) {
-        velociteY += gravite;
-        IV.setY(getY() + velociteY);
-        double WidthJ = IV.getImage().getWidth();
-        double HeightJ = IV.getImage().getHeight();
-
-        BoundingBox joueurBound = new BoundingBox(IV.getX(), IV.getY(), WidthJ, HeightJ);
-        //COORDONNES JOUEUR
-        double BasJ = joueurBound.getMaxY();
-        double HautJ = joueurBound.getMinY();
-        double GaucheJ = joueurBound.getMinX();
-        double DroiteJ = joueurBound.getMaxX();
-        //System.out.println(HautJ);
-        //POUR TOUTES LES PLATEFORMES
-        for (Plateforme p : plateformeArrayList){
-            double WidthP =  p.getIV().getImage().getWidth();
-            double HeightP = p.getIV().getImage().getHeight();
-            BoundingBox platformBound = new BoundingBox(p.IV.getX(), p.IV.getY(), WidthP, HeightP);
-            //COORDONNES PLATEFORME
-            double BasP = platformBound.getMaxY();
-            double HautP = platformBound.getMinY();
-            double GaucheP = platformBound.getMinX();
-            double DroiteP = platformBound.getMaxX();
-            //System.out.println(HautP);
-            //System.out.println("hautP: ");
-            //System.out.println(HautP);
-            //System.out.println("basJ");
-            //System.out.println(BasJ);
-            if(BasJ >= HautP && GaucheJ <= DroiteP && DroiteJ >= GaucheP){ //COLLISION SOL Y
-                isCollideDown = true;
-                gravite = 0;
-                canJump = true;
-                System.out.println("collision sol");
-
-            }
-            if(HautJ >= BasP && GaucheJ <= DroiteP && DroiteJ >= GaucheP){ //COLLISION TETE Y
-                isCollideUp = true;
-                gravite = 10;
-                canJump = false;
-                System.out.println("collision tete");
-
-            }
-        }
-    }*/
 }
\ No newline at end of file
Index: project/src/controller/collision.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package controller;\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\n\r\nimport javafx.fxml.FXMLLoader;\r\nimport javafx.geometry.BoundingBox;\r\nimport javafx.scene.Parent;\r\nimport javafx.scene.Scene;\r\nimport javafx.scene.image.ImageView;\r\nimport javafx.stage.Stage;\r\nimport model.Entite;\r\nimport model.Joueur;\r\nimport model.Plateforme;\r\n\r\npublic class collision{\r\n\r\n    public void verify(ArrayList<Plateforme> p){\r\n        updateMouvementX(p);\r\n        updateMouvementY(p);\r\n    }\r\n\r\n    private void updateMouvementX(ArrayList<Plateforme> plateformeList){\r\n        for(Plateforme p : plateformeList){\r\n            ImageView pIV = p.getIV();\r\n            double WidthP =  p.getIV().getImage().getWidth();\r\n            double HeightP = p.getIV().getImage().getHeight();\r\n            BoundingBox platformBound = new BoundingBox(p.IV.getX(), p.IV.getY(), WidthP, HeightP);\r\n        }\r\n    }\r\n\r\n    private void updateMouvementY(){\r\n\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/project/src/controller/collision.java b/project/src/controller/collision.java
--- a/project/src/controller/collision.java	(revision 679b5b0aa11107999f56a7df48c9f96aa10c3cd2)
+++ b/project/src/controller/collision.java	(date 1642169504074)
@@ -11,24 +11,106 @@
 import model.Entite;
 import model.Joueur;
 import model.Plateforme;
+import controller.mouvement;
 
-public class collision{
+public class collision {
 
-    public void verify(ArrayList<Plateforme> p){
-        updateMouvementX(p);
-        updateMouvementY(p);
+    public boolean isCollideLeft;
+    public boolean isCollideRight;
+    public boolean isCollideUp;
+    public boolean isCollideDown;
+
+    public boolean canJump;
+    public boolean isInJump = false;
+
+    public void verify(ArrayList<Plateforme> p, Joueur j){
+        updateMouvementX(p, j);
+        updateMouvementY(p, j);
     }
 
-    private void updateMouvementX(ArrayList<Plateforme> plateformeList){
+    private void updateMouvementX(ArrayList<Plateforme> plateformeList, Joueur j){
+        ImageView JIV = j.getIV();
+        double WidthJ = JIV.getImage().getWidth();
+        double HeightJ = JIV.getImage().getHeight();
+        BoundingBox joueurBound = new BoundingBox(JIV.getX(), JIV.getY(), WidthJ, HeightJ);
         for(Plateforme p : plateformeList){
-            ImageView pIV = p.getIV();
+            ImageView PIV = p.getIV();
             double WidthP =  p.getIV().getImage().getWidth();
             double HeightP = p.getIV().getImage().getHeight();
-            BoundingBox platformBound = new BoundingBox(p.IV.getX(), p.IV.getY(), WidthP, HeightP);
+            BoundingBox platformBound = new BoundingBox(PIV.getX(), PIV.getY(), WidthP, HeightP);
+            //COORDONNES JOUEUR
+            double BasJ = joueurBound.getMaxY();
+            double HautJ = joueurBound.getMinY();
+            double GaucheJ = joueurBound.getMinX();
+            double DroiteJ = joueurBound.getMaxX();
+            //COORDONNES PLATEFORME
+            double BasP = platformBound.getMaxY();
+            double HautP = platformBound.getMinY();
+            double GaucheP = platformBound.getMinX();
+            double DroiteP = platformBound.getMaxX();
+
+            // COLLISION PAR LA GAUCHE X
+            if(GaucheJ >= DroiteP && HautP <= HautJ && BasP >= BasJ){
+                isCollideLeft = true;
+            }
+
+            //COLLISION PAR LA DROITE X
+            if(DroiteJ >= GaucheP && HautJ <= HautP && BasJ >= BasP){
+                isCollideRight = true;
+            }
         }
     }
 
-    private void updateMouvementY(){
+    private void updateMouvementY(ArrayList<Plateforme> plateformeList, Joueur j){
+        ImageView JIV = j.getIV();
+        //GRAVITE
+        /*if(j.mouvementUp()){
+            j.gravite();
+        } else {
+            double gravite;
+            gravite = 0;
+            j.setGravite(gravite);
+        }*/
+        double WidthJ = JIV.getImage().getWidth();
+        double HeightJ = JIV.getImage().getHeight();
+        BoundingBox joueurBound = new BoundingBox(JIV.getX(), JIV.getY(), WidthJ, HeightJ);
+        for(Plateforme p : plateformeList){
+            ImageView PIV = p.getIV();
+            double WidthP =  p.getIV().getImage().getWidth();
+            double HeightP = p.getIV().getImage().getHeight();
+            BoundingBox platformBound = new BoundingBox(PIV.getX(), PIV.getY(), WidthP, HeightP);
+            //COORDONNES JOUEUR
+            double BasJ = joueurBound.getMaxY();
+            double HautJ = joueurBound.getMinY();
+            double GaucheJ = joueurBound.getMinX();
+            double DroiteJ = joueurBound.getMaxX();
+            //COORDONNES PLATEFORME
+            double BasP = platformBound.getMaxY();
+            double HautP = platformBound.getMinY();
+            double GaucheP = platformBound.getMinX();
+            double DroiteP = platformBound.getMaxX();
 
+            //COLLISION TETE Y
+            if(HautP >= BasJ && HautJ >= BasP && GaucheJ <= DroiteP && DroiteJ >= GaucheP){
+                isCollideUp = true;
+                canJump = false;
+            }
+
+            //COLLISION SOL
+            if(BasJ >= HautP && BasP >= HautJ && GaucheJ <= DroiteP && DroiteJ >= GaucheP){
+                isCollideDown = true;
+                canJump = true;
+                //System.out.println("collision sol");
+            }
+
+
+            /*if(isCollideDown) { j.setGravite(0); }
+
+            if(isCollideUp){ j.arretSaut(); }
+
+            if (isCollideRight){ j.arretMouvementAvant(); }
+
+            if (isCollideRight){ j.arretMouvementArriere(); }*/
+        }
     }
 }
Index: project/src/controller/mouvement.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package controller;\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\n\r\nimport javafx.fxml.FXMLLoader;\r\nimport javafx.geometry.BoundingBox;\r\nimport javafx.scene.Parent;\r\nimport javafx.scene.Scene;\r\nimport javafx.scene.image.ImageView;\r\nimport javafx.stage.Stage;\r\nimport model.Entite;\r\nimport model.Joueur;\r\nimport model.Plateforme;\r\n\r\n// Classe stockant une liste de touche pour les mouvements a finir ??\r\n\r\npublic class mouvement {\r\n    private ArrayList<String> input;\r\n\r\n    public mouvement() {\r\n        input = new ArrayList<String>();\r\n    }\r\n\r\n    public ArrayList<String> getInput() {\r\n        return input;\r\n    }\r\n\r\n    public void addInput(String s) {\r\n        input.add(s);\r\n    }\r\n\r\n    public void removeInput(String s) {\r\n\r\n        input.remove(s);\r\n    }\r\n\r\n    public void clearInput() {\r\n        for (String in : input) {\r\n            input.remove(in);\r\n        }\r\n\r\n    }\r\n\r\n    public Boolean ActionLectureListe(mouvement mouvementJoueur, Joueur j1, Stage stage, ArrayList<Entite> entites) {\r\n\r\n        if (mouvementJoueur.getInput().contains(\"LEFT\")) {\r\n            j1.mouvementarriereX();\r\n\r\n        } else if (mouvementJoueur.getInput().contains(\"RIGHT\")) {\r\n            j1.mouvementavantX();\r\n\r\n        } else if (mouvementJoueur.getInput().contains(\"UP\")) {\r\n            j1.saut();\r\n\r\n        } else if (mouvementJoueur.getInput().contains(\"ESCAPE\")) {\r\n            //sauvegarde auto\r\n            //lance nouveau menu avec comme option : recommencer le jeu et quitter\r\n            System.out.println(\"quitter\");\r\n            stage.close();\r\n            Parent root = null;\r\n            try {\r\n                root = (Parent) FXMLLoader.load(getClass().getClassLoader().getResource(\"fxml/accueil.fxml\"));\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n            Scene scene = new Scene(root, 900, 520);\r\n            stage.setScene(scene);\r\n\r\n            return false;\r\n        } else\r\n            j1.arretmouvement();\r\n\r\n        return true;\r\n    }\r\n\r\n/*\r\n    public Boolean CheckCollision (Joueur j, ArrayList<Plateforme> plateformeArrayList) {\r\n        //System.out.println(J.getX());\r\n        int WidthJ = (int) j.getImage().getWidth();\r\n        int HeightJ = (int) j.getImage().getHeight();\r\n        BoundingBox joueurBound = new BoundingBox(j.getX(), j.getY(), WidthJ, HeightJ);\r\n\r\n        //pour toutes les plateformes dans la liste\r\n        for (Plateforme p : plateformeArrayList){\r\n            int WidthP = (int) p.getImage().getWidth();\r\n            int HeightP = (int) p.getImage().getHeight();\r\n            BoundingBox platformBound = new BoundingBox(p.getX(), p.getY(), WidthP, HeightP);\r\n\r\n            if( platformBound.intersects(joueurBound) ) {\r\n                System.out.println(\"Collision\");\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }//Y hauteur // X largeur*/\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/project/src/controller/mouvement.java b/project/src/controller/mouvement.java
--- a/project/src/controller/mouvement.java	(revision 679b5b0aa11107999f56a7df48c9f96aa10c3cd2)
+++ b/project/src/controller/mouvement.java	(date 1642170019813)
@@ -12,9 +12,8 @@
 import model.Joueur;
 import model.Plateforme;
 
-// Classe stockant une liste de touche pour les mouvements a finir ??
-
 public class mouvement {
+
     private ArrayList<String> input;
 
     public mouvement() {
@@ -30,7 +29,6 @@
     }
 
     public void removeInput(String s) {
-
         input.remove(s);
     }
 
@@ -38,24 +36,24 @@
         for (String in : input) {
             input.remove(in);
         }
-
     }
+
 
     public Boolean ActionLectureListe(mouvement mouvementJoueur, Joueur j1, Stage stage, ArrayList<Entite> entites) {
 
         if (mouvementJoueur.getInput().contains("LEFT")) {
-            j1.mouvementarriereX();
+            j1.mouvementLeft();
+            //j1.mouvementarriereX();
 
         } else if (mouvementJoueur.getInput().contains("RIGHT")) {
-            j1.mouvementavantX();
+            j1.mouvementRight();
+            //j1.mouvementavantX();
 
         } else if (mouvementJoueur.getInput().contains("UP")) {
-            j1.saut();
+            j1.mouvementUp();
+            //j1.saut();
 
         } else if (mouvementJoueur.getInput().contains("ESCAPE")) {
-            //sauvegarde auto
-            //lance nouveau menu avec comme option : recommencer le jeu et quitter
-            System.out.println("quitter");
             stage.close();
             Parent root = null;
             try {
@@ -65,33 +63,8 @@
             }
             Scene scene = new Scene(root, 900, 520);
             stage.setScene(scene);
-
             return false;
-        } else
-            j1.arretmouvement();
-
-        return true;
-    }
-
-/*
-    public Boolean CheckCollision (Joueur j, ArrayList<Plateforme> plateformeArrayList) {
-        //System.out.println(J.getX());
-        int WidthJ = (int) j.getImage().getWidth();
-        int HeightJ = (int) j.getImage().getHeight();
-        BoundingBox joueurBound = new BoundingBox(j.getX(), j.getY(), WidthJ, HeightJ);
-
-        //pour toutes les plateformes dans la liste
-        for (Plateforme p : plateformeArrayList){
-            int WidthP = (int) p.getImage().getWidth();
-            int HeightP = (int) p.getImage().getHeight();
-            BoundingBox platformBound = new BoundingBox(p.getX(), p.getY(), WidthP, HeightP);
-
-            if( platformBound.intersects(joueurBound) ) {
-                System.out.println("Collision");
-                return true;
-            }
-        }
-        return false;
-    }//Y hauteur // X largeur*/
-
+        }
+        return true;
+    }
 }
\ No newline at end of file
